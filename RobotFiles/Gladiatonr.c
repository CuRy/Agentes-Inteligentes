#pragma config(Sensor, S4,     light,          sensorLightActive)
#pragma config(Sensor, S1,     eyes,           sensorSONAR)
#pragma config(Sensor, S2,     fronToque,      sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define STATE_IDLE 0
#define STATE_SEARCH 1
#define STATE_PUSH 2
#define STATE_AVOID_EDGE 3
#define STATE_AVOID_ROBOT 4
#define STATE_CALIBRATE 5
#define STATE_FACEROBOT 6
#define STATE_CHARGE 7
#define STATE_INTRO 8

#define LIGHT_LINE 40
#define NEAR_ROBOT 20
#define KINDO_NEAR 35

// globals
int state = STATE_IDLE;


/*
 * MEDIA VUELTA
 */
void mediaVuelta()
{
	motor[motorA] = 100;
	motor[motorB] = -100;
	wait1Msec(600);
}
/*
 * DETENER TODOS LOS MOTORES
 */
void stopAllMotors()
{
	motor[motorA] = 0;
	motor[motorB] = 0;
}

void moveedge()
{
	motor[motorA] = -50;
	motor[motorB] = -50;
	wait1Msec(200);
	motor[motorA] = -50;
	motor[motorB] = 50;
	wait1Msec(400);
}

/*
 * PONER VALOR A TODOS LOS MOTORES
 */
void setAllMotors(int value)
{
	motor[motorA] = value;
	motor[motorB] = value;
}

/******************************************************
 ****************** FACE2FACE *************************
 ******************************************************/

void facetoface()
{
	motor[motorA] = -100;
	motor[motorB] = 100;
	wait1Msec(200);
	state = STATE_CHARGE;
}

/******************************************************
 **************** SEARCH STATE FUNCTION ***************
 ******************************************************/
void doSearch()
{
	setAllMotors(40);
	// state change validations
	if(SensorValue(fronToque) == 1)
	{
		state = STATE_PUSH;
	}else if(SensorValue(light) < LIGHT_LINE)
	{
		stopAllMotors();
		state = STATE_AVOID_EDGE;
	}else if(SensorValue(eyes) < NEAR_ROBOT)
	{
		//stopAllMotors();
		facetoface();
		//state = STATE_AVOID_ROBOT;
	}else if(SensorValue(eyes) < KINDO_NEAR)
	{
		//turn face to face with enemy robot
		facetoface();
	}else //do the state stuff
	{
		writeDebugStreamLine("STATE_SEARCH");
		setAllMotors(80);
	}
}

/******************************************************
 ***************** PUSH STATE FUNCTION ****************
 ******************************************************/
void doPush()
{
	// state change validations
	if(SensorValue(fronToque) == 0)
	{
		stopAllMotors();
		state = STATE_SEARCH;
	}else if(SensorValue(light) < LIGHT_LINE)
	{
		stopAllMotors();
		state = STATE_AVOID_EDGE;
	}else if(SensorValue(eyes) < NEAR_ROBOT)
	{
		facetoface();
	}else // do the state stuff
	{
		setAllMotors(150);
		writeDebugStreamLine("STATE_PUSH");
	}
}

/******************************************************
 ***************** IDLE STATE FUNCTION ****************
 ******************************************************/
void doIdle()
{
	// state change validations
	if(SensorValue(fronToque) == 1)
	{
		stopAllMotors();
		state = STATE_PUSH;
	}else if(SensorValue(light) < LIGHT_LINE)
	{
		stopAllMotors();
		state = STATE_SEARCH;
	}else if(SensorValue(eyes) < NEAR_ROBOT)
	{
		stopAllMotors();
		state = STATE_SEARCH;
	}else // do the state stuff
	{
		writeDebugStreamLine("STATE_IDLE");
	}
}

/******************************************************
 ************** AVOID EDGE STATE FUNCTION *************
 ******************************************************/
void doAvoidEdge()
{
	// state change validations
	if(SensorValue(fronToque) == 1)
	{
		stopAllMotors();
		state = STATE_PUSH;
	}
	else if(SensorValue(eyes) < NEAR_ROBOT)
	{
		facetoface();
	}
	else if(SensorValue(eyes) < KINDO_NEAR)
	{
		//turn face to face with enemy robot
		facetoface();
	}else //do the state stuff
	{
		moveedge();
		state = STATE_SEARCH;
		writeDebugStreamLine("STATE_AVOID_EDGE");
	}
}


/******************************************************
 ************** AVOID ROBOT STATE FUNCTION ************
 ******************************************************/
void doAvoidRobot()
{
	// state change validations
	if(SensorValue(light) < LIGHT_LINE)
	{
		stopAllMotors();
		state = STATE_AVOID_EDGE;
	}else // do the state stuff
	{
		moveedge();
		writeDebugStreamLine("STATE_AVOID_ROBOT");
		state= STATE_PUSH;
	}
}

/******************************************************
 ****************** CALIBRATE FUNCTION ****************
 ******************************************************/
void doCalibrate()
{
	// state change validations
	{
		clearDebugStream();
		writeDebugStreamLine("  Light: %d", SensorValue(light));
		writeDebugStreamLine("  Touch: %d", SensorValue(fronToque));
		writeDebugStreamLine("  Eyes:  %d", SensorValue(eyes));
		wait1Msec(100);
	}
}

/******************************************************
 ****************** CHARGE ****************************
 ******************************************************/
void charge()
{
	setAllMotors(80);

	if(SensorValue(fronToque) == 1)
	{
		state = STATE_PUSH;
	}else if(SensorValue(light) < LIGHT_LINE)
	{
		stopAllMotors();
		state = STATE_AVOID_EDGE;
	}else if(SensorValue(eyes) < NEAR_ROBOT)
	{
		facetoface();
	}else if(SensorValue(eyes) < NEAR_ROBOT)
	{
		facetoface();
	}else //do the state stuff
	{
		writeDebugStreamLine("STATE_SEARCH");
	}
}

/******************************************************
 *********************** INTRO ************************
 ******************************************************/
void doIntro()
{
	// small intro (9 secs)
	// wait1Msec(9000);

	// first shakes
	int shakespd = 50;
	int smallpause = 200;
	int longpause = 800;

	motor[motorC] = -100;
	motor[motorA] = shakespd;
	motor[motorB] = -shakespd;
	wait1Msec(smallpause);
	stopAllMotors();
	motor[motorC] = 0;
	wait1Msec(longpause);

	motor[motorC] = 100;
	motor[motorA] = -shakespd;
	motor[motorB] = shakespd;
	wait1Msec(smallpause);
	stopAllMotors();
	motor[motorC] = 0;
	wait1Msec(smallpause);
	motor[motorC] = -100;
	motor[motorA] = shakespd;
	motor[motorB] = -shakespd;
	wait1Msec(smallpause);
	stopAllMotors();
	motor[motorC] = 0;
	wait1Msec(smallpause);
	motor[motorC] = 100;
	motor[motorA] = -shakespd;
	motor[motorB] = shakespd;
	wait1Msec(smallpause);
	motor[motorC] = 0;
	stopAllMotors();
	wait1Msec(1200);

	motor[motorC] = 100;
	motor[motorA] = -shakespd;
	motor[motorB] = shakespd;
	wait1Msec(smallpause);
	stopAllMotors();
	motor[motorC] = 0;
	wait1Msec(smallpause);
	motor[motorC] =-100;
	motor[motorA] = shakespd;
	motor[motorB] = -shakespd;
	wait1Msec(smallpause);
	stopAllMotors();
	motor[motorC] = 0;
	wait1Msec(smallpause);
	motor[motorC] = 100;
	motor[motorA] = -shakespd;
	motor[motorB] = shakespd;
	wait1Msec(smallpause);
	stopAllMotors();
	motor[motorC] = 0;
	wait1Msec(1200);

	motor[motorC] = 100;
	motor[motorA] = -shakespd;
	motor[motorB] = shakespd;
	wait1Msec(smallpause);
	stopAllMotors();
	motor[motorC] = 0;
	wait1Msec(smallpause);
	motor[motorC] = -100;
	motor[motorA] = shakespd;
	motor[motorB] = -shakespd;
	wait1Msec(smallpause);
	stopAllMotors();
	motor[motorC] = 0;
	wait1Msec(smallpause);
	motor[motorC] = 100;
	motor[motorA] = -shakespd;
	motor[motorB] = shakespd;
	wait1Msec(2800);
	stopAllMotors();

	PlaySound(soundBeepBeep);
}

/******************************************************
 ******************** MAIN FUNCTION *******************
 ******************************************************/
task main()
{
	// arranque

	//motor[motorC] = 20;

	state = STATE_SEARCH;

	//state = STATE_CALIBRATE;

	while(1)
	{
		switch(state)
		{
			case STATE_SEARCH:
				doSearch();
				break;

			case STATE_PUSH:
				doPush();
				break;

			case STATE_IDLE:
				doIdle();
				break;

			case STATE_AVOID_EDGE:
				doAvoidEdge();
				break;

			case STATE_AVOID_ROBOT:
				doAvoidRobot();
				break;

			case STATE_CALIBRATE:
				doCalibrate();
				break;

			case STATE_FACEROBOT:
				facetoface();
				break;

			case STATE_CHARGE:
				charge();
				break;

			case STATE_INTRO:
				doIntro();
				break;

			default: // no deberia suceder
				break;
		}
	}
}
